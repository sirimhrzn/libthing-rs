This compiles to three different target family.
- android
- ios
- wasm
Also has some conditional compilation stuff to ensure we do not bundle unnecessary dependencies for a given target.

# Build

The build script for each platform is available at the `common` directory.
- ./common/build_wasm.nu
- ./common/build_ios.nu 
- ./common/build_android.nu

# android

## Requirements
- android studio (sdk & ndk)
- cargo-ndk
- gradle
- jdk ( easy to install via android studio)
## Creating android module
Since we are building a package that will contain external libs & the FFI bindings, the package must be bundled with the external libs (`*.so` files). If we create a `.jar` , it will only contain the code and not the `resources` directory (contains external libs `*.so` ).  To contain the external libs we must create a `.aar` file.
Well creating a module is weirdly weird cause you to create a android project first, then only you can create a module. Follow this [tutorial](https://developer.android.com/studio/projects/android-library) to create a module.
> Also while creating a new module, do not forget to select Android Library, i wasted couple hours debugging because I created the `Phone & Tablet` module which was selected by default.

The module directory should contain  `<module-dir>/src/main/jniLibs` directory and inside it we create directories per  [android supported abi's](https://developer.android.com/ndk/guides/abis#sa)  and inside them we store the external lib `.so` file.  The directory structure should look something like this.
```bash
calendarcore
└── src
    ├── main
    │   ├── kotlin
    │   │   └── uniffi # bindings generated by uniffi-bindgen
    │   │       └── calendarcore
    │   │           └── calendarcore.kt
    │   └── jniLibs
    │       ├── arm64-v8a
    │       │   └── libcalendarcore.so #rust-target: aarch64-linux-android
    │       ├── armeabi-v7a
    │       │   └── libcalendarcore.so #rust-target: armv7-linux-androideabi 
    │       └── x86_64
    │           └── libcalendarcore.so #rust-target: x86_64-linux-android 
```

> The generated FFI bindings shall be copied over to the module's `src/main/kotlin` directory.

The FFI bindings for Kotlin generated by  uniffi-bindgen has a dependency on the `jna` package so add this as the module dependency via `Settings Icon > Project Structure > Dependencies -> + -> Library Dependency.
```kt
net.java.dev.jna:jna 
```

After populating the module with the external libs & bindings, build the `.aar` file which then can be imported into another project.
```bash
./gradlew :<module-name>:assembleDebug
```

The command should output the `.aar` file inside the module's build directory.
```
calendarcore
├── build
│   ├── outputs
│   │   ├── aar
│   │   │   └── calendarcore-debug.aar
```

Now this `.aar` file can be imported into your android project as a dependency.
> The android project where you import this `.aar`  also should add `implementation("net.java.dev.jna:jna:5.17.0@aar")` in their **dependencies** in `build.gradle.kts`, i'm no android expert so i can't answer the why.

Then the external libraries functions can be called via the namespace `uniffi.*` .
-----------------------------------------------------
# ios
For getting external libraries to work on iOS platforms, we need to create a xcframework, (think of it as a module/bundle/directory/framework) .  XCFramework allows to ship multi-platform & multi-arch libraries. It is a solution to something called a FAT binary, previously used to build binaries that worked on both x86 & arm.Xcframework is created via the `xcodebuild -create-xcframework` command to which we can pass the shared library `.a` and it's header files `.h`   via `--library` and `--headers`  flag respectively. This is the library way of doing things, xcframework can also be used to ship an actual framework, this requires creating something called a xcarchive via `xcodebuild archive`.   [All about XCFrameworks](https://www.humancode.us/2023/05/19/all-about-xcframeworks.html) has a better explanation on this.
# UniFFI
This is a tool built by the Mozilla team which allows to generate FFI bindings of rust program for different languages including swift.
## Requirements
Well of-course you will need rust and cargo, outside of the rust ecosystem it will depend on these things.
- Xcode
- iPhoneOS.sdk
- iPhoneSimulator.sdk

> Use $SDKROOT to switch between sdk's for builds.

The Rust Library must have the following *Cargo.toml* config.
```toml
[lib]
crate-type = ["cdylib", "staticlib", "lib"]
# `cdylib`'s are primarily designed for building shared libraries that can be linked into C/C++ programs.
```
After you add this and build the library , it will output `target/<arch>/lib${lib.name}.a` file.

-------------------------------------------------------------
# Building & Packaging
I'll be going over my build script `build_ios.nu` and breaking down the functions and their purpose.
## Generating the FFI Bindings
This will generate the swift bindings and the header files. The swift files should be moved to your library location.
```nu
def generate_swift_ffi [ pkg, bindings_out ] {

  print $"Generating Swift FFI for ($pkg)"
  let module_name = $"($pkg)FFI"
  $targets
  | each { |target|
  (
      cargo run -p uniffi-bindgen-swift -- 
		$"target/($target)/release/lib($pkg).a" 
		$bindings_out
        --swift-sources
        --headers
        --modulemap
        --module-name $module_name
        --modulemap-filename module.modulemap
    )
  }

  print (ansi green) "Swift FFI generated ." (ansi reset)

}
```
## FAT Binary
This is only for ios simulators which could be running either x86 or arm, so we create a single fat binary containing native instruction of both architectures. The **lipo** program was available on my machine, I assume it came with the xcode build tools, but there also was a third party tool [lipo-go](https://github.com/konoui/lipo). 
```nu
def generate_fat_sim_lib [ pkg ] {

  let dir = "target/ios-simulator-fat/release"
  mkdir -v $dir

  print "Creating a Fat binary."

  (
    lipo -create
    $"target/x86_64-apple-ios/release/lib($pkg).a"
    $"target/aarch64-apple-ios-sim/release/lib($pkg).a"
    -output $"($dir)/lib($pkg).a"
  )

  print (ansi green) "Fat binary created." (ansi reset)
}
```
## XcFramework
This is the file containing the library for different platforms and architecture and the header files. The path to this file will be used in the `Package.swift`. 
```nu
def generate_xcframework [ pkg bindings_out ] {

  print "Generating XCFramwork..."

  let out = "target/ios"
  rm -rf target/ios
  (
    xcodebuild -create-xcframework
    -library $"target/ios-simulator-fat/release/lib($pkg).a" -headers $bindings_out
    # -library $"target/aarch64-apple-ios/release/lib($pkg).a" -headers $bindings_out
    -output $"($out)/lib($pkg)-rs.xcframework"
  )

  print (ansi green) $"Generated XCFramwork at ($out)" (ansi reset)
}
```

> Open your project's `xcodeproj` and below in the Frameworks, Libraries section add the generated `.xcframework`
## Swift Package
We specify the path of  the  **xcframework** , in a swift package in the binaryTarget. 
```swift
let binaryTarget: Target

binaryTarget = .binaryTarget(
    name: "CalendarCoreRs", 
    path: "./common/target/ios/libcalendarcore-rs.xcframework"
)
```

>According to [Ferrostar](https://github.com/stadiamaps/ferrostar/blob/main/Package.swift#L14), swift packages importing this locally will not be able to import  unless the path specified is a relative path.  

This is us exposing our many libraries. The two library pointing to the same target is just an example. The path in the target should contain the swift bindings generated via uniffi.

```swift
let package = Package(
    name: "CalendarCore",
    defaultLocalization: "en",
    platforms: [
        .iOS(.v16),
    ],
    products: [
        .library(
            name: "CalendarCore",
            targets: ["CalendarCoreUtils"]
        ),
        .library(
            name: "CalendarCoreMaterial",
            targets: ["CalendarCoreUtils"]
        ),
    ],
   targets: [
       binaryTarget, // Pass the binary target here as well.
        .target(
            name: "CalendarCoreUtils", // This will be used in the import <lib>
            dependencies: [

            ],
            path: "apple/calendarcore"
        ),
    ]
)
```

Add this package as your dependency on your ios project and also do not forget to add the `.xcframework` to the project's `Framework, Libraries` section, since that will contain the actual binaries & header files. After you've done all this you should be able to import the library and call the rust functions.
# Issues & Fixes
Well for some obscure reasons, after adding the rusqlite with libsqlite-sys bundled it fails to build. I'm not sure if its related to nix.
Issue Trackers
- https://gitlab.haskell.org/ghc/ghc/-/issues/20162
- https://gitlab.haskell.org/ghc/ghc/-/issues/25907
- https://github.com/NixOS/nixpkgs/issues/395191
Fix:
```
brew update
brew install llvm
brew install autoconf automake

export CPPFLAGS="-I/opt/homebrew/opt/llvm/include"
export LDFLAGS="-L/opt/homebrew/opt/llvm/lib"
export CC=/opt/homebrew/opt/llvm/bin/clang
export CXX=/opt/homebrew/opt/llvm/bin/clang++
export AR=/opt/homebrew/opt/llvm/bin/llvm-ar
```
## Acknowledgements
- [UniFFI](https://github.com/mozilla/uniffi-rs)
- [Ferrostar](https://github.com/stadiamaps/ferrostar)
- [All about XCFrameworks](https://www.humancode.us/2023/05/19/all-about-xcframeworks.html)

